---
output: github_document
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)

library(MajorTrackR)
library(plot.matrix)
library(igraph)
library(ggthemes)

mycircle <- function(coords, v=NULL, params) {
  vertex.color <- params("vertex", "color")
  if (length(vertex.color) != 1 && !is.null(v)) {
    vertex.color <- vertex.color[v]
  }
  vertex.size  <- 1/200 * params("vertex", "size")
  if (length(vertex.size) != 1 && !is.null(v)) {
    vertex.size <- vertex.size[v]
  }
  vertex.frame.color <- params("vertex", "frame.color")
  if (length(vertex.frame.color) != 1 && !is.null(v)) {
    vertex.frame.color <- vertex.frame.color[v]
  }
  vertex.frame.width <- params("vertex", "frame.width")
  if (length(vertex.frame.width) != 1 && !is.null(v)) {
    vertex.frame.width <- vertex.frame.width[v]
  }
  
  mapply(coords[,1], coords[,2], vertex.color, vertex.frame.color,
         vertex.size, vertex.frame.width,
         FUN=function(x, y, bg, fg, size, lwd) {
           symbols(x=x, y=y, bg=bg, fg=fg, lwd=lwd,
                   circles=size, add=TRUE, inches=FALSE)
         })
}

mysquare <- function(coords, v=NULL, params) {
  vertex.color <- params("vertex", "color")
  if (length(vertex.color) != 1 && !is.null(v)) {
    vertex.color <- vertex.color[v]
  }
  vertex.size  <- 1/100 * params("vertex", "size")
  if (length(vertex.size) != 1 && !is.null(v)) {
    vertex.size <- vertex.size[v]
  }
  vertex.frame.color <- params("vertex", "frame.color")
  if (length(vertex.frame.color) != 1 && !is.null(v)) {
    vertex.frame.color <- vertex.frame.color[v]
  }
  vertex.frame.width <- params("vertex", "frame.width")
  if (length(vertex.frame.width) != 1 && !is.null(v)) {
    vertex.frame.width <- vertex.frame.width[v]
  }
  
  mapply(coords[,1], coords[,2], vertex.color, vertex.frame.color,
         vertex.size, vertex.frame.width,
         FUN=function(x, y, bg, fg, size, lwd) {
           symbols(x=x, y=y, bg=bg, fg=fg, lwd=lwd,
                   squares=size, add=TRUE, inches=FALSE)
         })
}



add.vertex.shape("fcircle", clip=igraph.shape.noclip,
		plot=mycircle, parameters=list(vertex.frame.color=1,
                                  vertex.frame.width=1))

add.vertex.shape("fsquare", clip=igraph.shape.noclip,
		plot=mysquare, parameters=list(vertex.frame.color=1,
                                  vertex.frame.width=1))

```

# MajorTrackR

R interface for the majortrack python library for carrying out dynamic 	community detection method tracking persistent but transiently discontinuous communities in time window graphs.
See: https://github.com/j-i-l/MajorTrack for required python library 
See: https://majortrack.readthedocs.io/en/latest/ for python documentation.
See: https://arxiv.org/abs/1912.04261 for associated paper.

## Installation

MajorTrackR requires a python install (3+) with MajorTrackR installed. Most common scientific python distributions such as Anaconda sould be fine. Once you have python installed, you can install MajorTrack from the [github repository](https://github.com/j-i-l/MajorTrack). Using pip is the easiest way to do this:

```{bash,eval=FALSE}
pip install --upgrade git+https://github.com/j-i-l/majortrack.git

```

Once this is done, you can install the R package using:

``` {r install from github,eval=F}
devtools::install_git("https://github.com/jevansbio/MajorTrackR",build_vignettes = T)

```

Once this is ready, you can start working with MajorTrack in R

Firstly we need to load the appropriate packages. We'll use igraph to build our networks.


```{r load package,eval=FALSE}
library(igraph)
library(MajorTrackR)
```

For this tutorial we'll use some generated network data. See the full vignette for the code to generate this from scratch.

```{r load data}
data(allnets)
```

For each series of networks, I'll show both a consistent layout where nodes remain in the same place in each timestep, and a per-timestep layout where nodes will shift position depending on their social associations during that timestep.

```{r plotting0,fig.cap="All networks",dpi=600,echo = F,out.width="100%"}

lighten <- function(color, factor = 0.5) {
  if ((factor > 1) | (factor < 0)) stop("factor needs to be within [0,1]")
  col <- col2rgb(color)
  col <- col + (255 - col)*factor
  col <- rgb(t(col), maxColorValue=255)
  col
}

par(mfrow=c(2,3),mar=c(0,0,0,0))
cols=gdocs_pal()(10)


#start=matrix(jitter(c(V(x)$group*500,rep(0,length(V(x)$group))),amount=5),ncol=2)

l1=layout_with_graphopt(allnets[[1]],niter=1500,charge=0.02,mass=30,spring.length = 0, max.sa.movement	= 5)
l2=list()
l2[[1]]=l1
for(i in 2:length(allnets)){
  currnet=allnets[[i]]
  l2[[i]]=layout_with_graphopt(currnet,start=l2[[i-1]],niter=1500,charge=0.02,mass=30,spring.length = 0, max.sa.movement	= 5)
}

for(i in 1:length(allnets)){
  currnet=allnets[[i]]
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  #for(j in unique(E(currnet)$group)[2:length(unique(E(currnet)$group))]){
  #  currcol=cols[j]
  #  edgecols[E(currnet)$group==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$group==j]),maxColorValue=256)
  #}  
  #nodecols = cols[V(currnet)$group]
  nodecols = "white"
  
  plot(currnet,layout=l1,vertex.label="",
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.5,
       vertex.color=nodecols,vertex.size=10,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}
```

```{r plotting1,fig.cap="All networks",dpi=600,out.width="100%",echo = F}

lighten <- function(color, factor = 0.5) {
  if ((factor > 1) | (factor < 0)) stop("factor needs to be within [0,1]")
  col <- col2rgb(color)
  col <- col + (255 - col)*factor
  col <- rgb(t(col), maxColorValue=255)
  col
}

par(mfrow=c(2,3),mar=c(0,0,0,0))
cols=gdocs_pal()(10)


#start=matrix(jitter(c(V(x)$group*500,rep(0,length(V(x)$group))),amount=5),ncol=2)

for(i in 1:length(allnets)){
  currnet=allnets[[i]]
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  #for(j in unique(E(currnet)$group)[2:length(unique(E(currnet)$group))]){
  #  currcol=cols[j]
  #  edgecols[E(currnet)$group==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$group==j]),maxColorValue=256)
  #}  
  #nodecols = cols[V(currnet)$group]
  nodecols = "white"
  
  plot(currnet,layout=l2[[i]],vertex.label="",vertex.color=nodecols,vertex.size=10,
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.5,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}
```

## 2. Detecting communities

If this were a real network, we'd need to detect our communities. The method you use to do this will depend on on your style of network. I am using Louvain clustering here:

```{r Detect communities}
#detect each networks communities
coms=lapply(allnets,function(x){
	cluster_louvain(x)
})


#apply community membership as node attribute
allnets=lapply(1:length(allnets),function(x){
	V(allnets[[x]])$com=coms[[x]]$membership
	allnets[[x]]
})

#For convenience, just pull out the memberships
allcoms=lapply(1:length(allnets),function(x){
  coms[[x]]$membership
})

```


Our node order doesn't change between networks and the communities are very clear, so the algorithm does pretty well  returning some community memberships in the same order each time. However this means some strangeness, such as in the second timestep where community 4 (green) gets reassigned as community 3 (gold), because the original community 3 merges with community 2. Though this is pretty obvious here, this might not be the case with real networks! Keeping track of a community consistently over time is one of the main advantages of majortrack   

```{r plotting2,fig.cap=c("All networks with communities, consistent layout","All networks with communities, per-timestep layout"),dpi=600,out.width="100%",echo = F}


par(mfrow=c(2,3),mar=c(0,0,0,0))
cols=gdocs_pal()(10)


for(i in 1:length(allnets)){
  currnet=allnets[[i]]
  
  currdatalist=as_data_frame(currnet,"both")
  currdata=as_long_data_frame(currnet)
  currdata$same_com=currdata$from_com==currdata$to_com
  currdata$com=0
  currdata$com[currdata$same_com]=currdata$from_com[currdata$same_com]
  currdata=currdata[order(currdata$weight),]
  currnet=graph_from_data_frame(currdata,directed=F,currdatalist$vertices)
  
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  for(j in unique(E(currnet)$com)[2:length(unique(E(currnet)$com))]){
    currcol=cols[j]
    edgecols[E(currnet)$com==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$com==j]),maxColorValue=256)
  }  
  nodecols = cols[V(currnet)$com]
  
  
  plot(currnet,layout=l1,vertex.label=V(currnet)$com,vertex.label.color="white",vertex.label.cex=0.75,
       vertex.color=nodecols,vertex.size=10,
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.5,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}

cat('\n\n')
par(mfrow=c(2,3),mar=c(0,0,0,0))
cols=gdocs_pal()(10)


for(i in 1:length(allnets)){
  currnet=allnets[[i]]
  
  currdatalist=as_data_frame(currnet,"both")
  currdata=as_long_data_frame(currnet)
  currdata$same_com=currdata$from_com==currdata$to_com
  currdata$com=0
  currdata$com[currdata$same_com]=currdata$from_com[currdata$same_com]
  currdata=currdata[order(currdata$weight),]
  currnet=graph_from_data_frame(currdata,directed=F,currdatalist$vertices)
  
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  for(j in unique(E(currnet)$com)[2:length(unique(E(currnet)$com))]){
    currcol=cols[j]
    edgecols[E(currnet)$com==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$com==j]),maxColorValue=256)
  }  
  nodecols = cols[V(currnet)$com]
  
  
  plot(currnet,layout=l2[[i]],vertex.label=V(currnet)$com,vertex.label.color="white",
       vertex.label.cex=0.75,
       vertex.color=nodecols,vertex.size=10,
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.75,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}
```
## 3. Running MajorTrack

To run MajorTrack we need  We also specify the history, start and stop parameters. We'll investigate history some more in a moment, but start and stop are fairly straightforward. If no stop is provided, the algorithm will just run to the end of the timesteps. 

```{r Run MajorTrack}
track <- do_track(allnets, coms, history=1)#run MajorTrack

```

Once we have this object we can get the membership of the "Dynamic communities", communities which persist over all the timesteps. These can then be added to our networks as a node attribute.

```{r Get dynamic communties}
dcmembership=get_dc_membership(track)
allnets = add_dc_membership(allnets,dcmembership)

```

```{r plotting3,fig.cap="All networks with dynamic communities",dpi=600,echo = F,out.width="100%"}



par(mfrow=c(2,3),mar=c(0,0,0,0))
cols=c(gdocs_pal()(10),"yellow")


for(i in 1:length(allnets)){
  currnet=allnets[[i]]
  
  currdatalist=as_data_frame(currnet,"both")
  currdata=as_long_data_frame(currnet)
  currdata$same_DC=currdata$from_DC==currdata$to_DC
  currdata$DC=-1
  currdata$DC[currdata$same_DC]=currdata$from_DC[currdata$same_DC]
  currdata=currdata[order(currdata$weight),]
  currnet=graph_from_data_frame(currdata,directed=F,currdatalist$vertices)
  
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  for(j in unique(E(currnet)$DC)[2:length(unique(E(currnet)$DC))]){
    currcol=cols[j+1]
    edgecols[E(currnet)$DC==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$DC==j]),maxColorValue=256)
  }  
  nodecols = cols[V(currnet)$DC+1]
  
  
  plot(currnet,layout=l1,vertex.label=V(currnet)$DC,vertex.label.color="white",
       vertex.label.cex=0.75,
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.5,
       vertex.color=nodecols,vertex.size=10,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}

cat('\n\n')

par(mfrow=c(2,3),mar=c(0,0,0,0))
cols=c(gdocs_pal()(10),"yellow")


for(i in 1:length(allnets)){
  currnet=allnets[[i]]
  
  currdatalist=as_data_frame(currnet,"both")
  currdata=as_long_data_frame(currnet)
  currdata$same_DC=currdata$from_DC==currdata$to_DC
  currdata$DC=-1
  currdata$DC[currdata$same_DC]=currdata$from_DC[currdata$same_DC]
  currdata=currdata[order(currdata$weight),]
  currnet=graph_from_data_frame(currdata,directed=F,currdatalist$vertices)
  
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  for(j in unique(E(currnet)$DC)[2:length(unique(E(currnet)$DC))]){
    currcol=cols[j+1]
    edgecols[E(currnet)$DC==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$DC==j]),maxColorValue=256)
  }  
  nodecols = cols[V(currnet)$DC+1]
  
  
  plot(currnet,layout=l2[[i]],vertex.label=V(currnet)$DC,vertex.label.color="white",
       vertex.label.cex=0.75,
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.5,
       vertex.color=nodecols,vertex.size=10,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}

```

You'll immediately notice a few things. First, this time round there is no reassigning of communities in the same timestep just because the number of communities has changed. The dynamic community remains the same. 

You might also notice that the merging and  splitting of communities results in completely new dynamic communities being "created", such as the purple community in timestep 2 when the yellow and red communities merge. This is due to the significant change in membership to the red community.

This slower transition eventually results in the membership of the dark blue community completely changing by the last timestep. The dark blue community in the final timestep has exactly the same membership as the dark green community from the first timestep. The membership has essentially "swapped" due to the gradual change in membership. 

Similarly, the purple community in the final timestep has exactly the same membership as the bright red community in the first timestep. In this case, the original community was "destroyed" during merging. The purple community then gradually changes membership until it reflected the original "destroyed" community. MajorTrack will not recover destroyed communities even if they have the same membership.

A couple of communities exist only for a single timestep (purple in timestep 2, light green in timestep 4, dark red in timestep 5). The emergence of these dynamic communities is dependent on the history parameter. Take a look at the same analysis run with a longer history parameter.

```{r different history par}
track2 <- do_track(allnets, coms, history=6)#run MajorTrack
dcmembership2=get_dc_membership(track2)
allnets2 = add_dc_membership(allnets,dcmembership2)

```

```{r plotting4,fig.cap=c("All networks with dynamic communities with longer history parameters, fixed layout","All networks with dynamic communities with longer history parameters, per-timstep layout"),dpi=600,echo = F,out.width="100%"}
par(mfrow=c(2,3),mar=c(0,0,0,0))
cols=c(gdocs_pal()(10),"yellow","brickred")


for(i in 1:length(allnets2)){
  currnet=allnets2[[i]]
  
  currdatalist=as_data_frame(currnet,"both")
  currdata=as_long_data_frame(currnet)
  currdata$same_DC=currdata$from_DC==currdata$to_DC
  currdata$DC=-1
  currdata$DC[currdata$same_DC]=currdata$from_DC[currdata$same_DC]
  currdata=currdata[order(currdata$weight),]
  currnet=graph_from_data_frame(currdata,directed=F,currdatalist$vertices)
  
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  for(j in sort(unique(E(currnet)$DC))[2:length(unique(E(currnet)$DC))]){
    currcol=cols[j+1]
    edgecols[E(currnet)$DC==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$DC==j]),maxColorValue=256)
  }  
  nodecols = cols[V(currnet)$DC+1]
  
  
  plot(currnet,layout=l1,vertex.label=V(currnet)$DC,vertex.label.color="white",
       vertex.label.cex=0.75,
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.5,
       vertex.color=nodecols,vertex.size=10,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}

cat('\n\n')

par(mfrow=c(2,3),mar=c(0,0,0,0))
cols=c(gdocs_pal()(10),"yellow","brickred")


for(i in 1:length(allnets2)){
  currnet=allnets2[[i]]
  
  currdatalist=as_data_frame(currnet,"both")
  currdata=as_long_data_frame(currnet)
  currdata$same_DC=currdata$from_DC==currdata$to_DC
  currdata$DC=-1
  currdata$DC[currdata$same_DC]=currdata$from_DC[currdata$same_DC]
  currdata=currdata[order(currdata$weight),]
  currnet=graph_from_data_frame(currdata,directed=F,currdatalist$vertices)
  
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  for(j in sort(unique(E(currnet)$DC))[2:length(unique(E(currnet)$DC))]){
    currcol=cols[j+1]
    edgecols[E(currnet)$DC==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$DC==j]),maxColorValue=256)
  }  
  nodecols = cols[V(currnet)$DC+1]
  
  
  plot(currnet,layout=l2[[i]],vertex.label=V(currnet)$DC,vertex.label.color="white",
       vertex.label.cex=0.75,
       vertex.color=nodecols,vertex.size=10,
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.5,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}
```

Here, the bright pink and light green communities never emerge. The longer history parameter leads to MajorTrack recognising these as being part of the dark blue and purple communities, as  they merge back into these communities in the subsequent timestep. The dark red community in timestep 4 remains however, as these individuals then merge with the light blue community, rather than returning to the dark blue community.

## 4. Getting more information about where dynamic communities come from

Some of the above might be hard to get just from the network diagrams. We can generate data tables that give us this information more clearly. The first thing we'll generate is a dataframe of "move events" showing the relationships between DCs from one timestep to another.

The table consists of 6 columns. The first column indicates the timestep, starting from the second timestep. The second column "parent" indicates which dynamic community in the previous timestep a "child" dynamic community (third column) emerged from in this timestep. 

The fourth column shows the type of event. This can be a "merge" - a dynamic community being created due to two dynamic communities joining together, a "split" - a dynamic community emerging as the result of a single dynamic community splitting up, a "move" - some nodes moving from one previously existing dynamic community to previously existing another and finally a "remain" - nodes staying in the same dynamic community as the previous timestep. By default, these only appear in the table if the parent/child is also involved in some other event.

The fifth column "moveid"  is a unique identifier combining the timestep, parent and child columns. Finally the "size" column shows how many nodes were involved in a particular event.

Here is an example of the first 3 timesteps in our networks, with MajorTrack run with a history parameter of 1.

```{r Get dynamic communty data}
comorigins = move_events_df(track)
head(comorigins, 9)#just the first two timesteps

```

```{r plotting7,fig.cap=c("All networks with dynamic communities showing identifiers, fixed layout","All networks with dynamic communities with longer history parameters, per-timstep layout"),dpi=600,echo = F,out.width="100%"}
par(mfrow=c(1,3),mar=c(0,0,0,0))
cols=c(gdocs_pal()(10),"yellow","brickred")


for(i in 1:3){
  currnet=allnets[[i]]
  
  currdatalist=as_data_frame(currnet,"both")
  currdata=as_long_data_frame(currnet)
  currdata$same_DC=currdata$from_DC==currdata$to_DC
  currdata$DC=-1
  currdata$DC[currdata$same_DC]=currdata$from_DC[currdata$same_DC]
  currdata=currdata[order(currdata$weight),]
  currnet=graph_from_data_frame(currdata,directed=F,currdatalist$vertices)
  
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  for(j in sort(unique(E(currnet)$DC))[2:length(unique(E(currnet)$DC))]){
    currcol=cols[j+1]
    edgecols[E(currnet)$DC==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$DC==j]),maxColorValue=256)
  }  
  nodecols = cols[V(currnet)$DC+1]
  
  
  plot(currnet,layout=l2[[i]],vertex.label=V(currnet)$DC,vertex.label.color="white",
       vertex.label.cex=0.75,vertex.color=nodecols,vertex.size=10,
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.5,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}


```

Each of the initial 4 communities we assigned consisted of 50 nodes. So Looking at the first 6 rows of the data table, we can see that all 50 members of DC 1 and all 50 members of DC 2 merge to create DC 4.

In the next timestep, we can see that all members of DC 0 stayed in that community, but were joined by 10 members of DC 3. Another 10 members of DC 3 moved to DC 4, while  the remaining 30 members remained where they were. DC 5 and DC 6 emerge as new DCs by splitting from DC 4. 

Here is another example of the first 3 timesteps in our networks, with the longer history parameter.

```{r Get dynamic communty data2}
comorigins2 = move_events_df(track2)
head(comorigins2, 9)#just the first two timesteps

```

```{r plotting6,fig.cap=c("All networks with dynamic communities showing identifiers, fixed layout","All networks with dynamic communities with longer history parameters, per-timstep layout"),dpi=600,echo = F,out.width="100%"}
par(mfrow=c(1,3),mar=c(0,0,0,0))
cols=c(gdocs_pal()(10),"yellow","brickred")


for(i in 1:3){
  currnet=allnets2[[i]]
  
  currdatalist=as_data_frame(currnet,"both")
  currdata=as_long_data_frame(currnet)
  currdata$same_DC=currdata$from_DC==currdata$to_DC
  currdata$DC=-1
  currdata$DC[currdata$same_DC]=currdata$from_DC[currdata$same_DC]
  currdata=currdata[order(currdata$weight),]
  currnet=graph_from_data_frame(currdata,directed=F,currdatalist$vertices)
  
  edgecols=rgb(colorRamp(c("grey","black"))(E(currnet)$weight),maxColorValue=256)
  for(j in sort(unique(E(currnet)$DC))[2:length(unique(E(currnet)$DC))]){
    currcol=cols[j+1]
    edgecols[E(currnet)$DC==j]=rgb(colorRamp(c(lighten(currcol,0.9),currcol))(E(currnet)$weight[E(currnet)$DC==j]),maxColorValue=256)
  }  
  nodecols = cols[V(currnet)$DC+1]
  
  
  plot(currnet,layout=l2[[i]],vertex.label=V(currnet)$DC,vertex.label.color="white",
       vertex.label.cex=0.75,vertex.color=nodecols,vertex.size=10,
       vertex.shape="fcircle",vertex.frame.color="black",vertex.frame.width=0.5,
       edge.width=E(currnet)$weight,edge.color=edgecols)
}


```
The major difference here is that due to the extended history parameter, DC 6 does not emerge here. Instead the split is regarded as temporary. DC 5 still splits from DC 4.

We can find out how long each DC lasts using the community_lifespans function:

```{r get lifespans}
community_lifespans(track)
```

## Get data about per individual dynamic community membership

It might also be useful to look at dynamic community membership at an individual level. 

```{r Get per individual DC data}
indmembership = ind_membership_df(dcmembership=dcmembership)
```
This function produces a list of two objects, each showing individual membership in a different way. The first is a dataframe with timestep, individual ID and DC membership as 3 columns:

```{r show per individual DC data1}
head(indmembership$memdf1)
```

This is useful for computation. For example, per timestep group size:

```{r calculate per timestep groupsize}
  #use a dummy variable to look at how many IDs are in each combination of timestep and groupsize
  groupsizes=aggregate(rep(1,nrow(indmembership$memdf1))~group+timestep,FUN=sum,data=indmembership$memdf1,drop=F)
  names(groupsizes)[3]="groupsize"
  groupsizes$groupsize[is.na(groupsizes$groupsize)]=0
  head(groupsizes,10)

```
From which we could obtain max groupsize over time:

```{r maxgroupsize}

aggregate(groupsize~group,FUN=max,data=groupsizes)
```


The second object in the ind_membership_df list is a matrix with a row for each individual and a column for each timestep. This is an easily readable way of looking at how an individual's membership changes over time.

```{r membership matrix}
head(indmembership$memdf2)

```

We could even visualise it. This is a plot using the plot.matrix library.

```{r visualisematrix,echo = F,out.width="100%",dpi=300,fig.height=2}
par(mar=c(3,2,1,1))
plot(indmembership$memdf2,xlab="",ylab="",breaks=seq(-0.5,9.5,1),col=c(gdocs_pal()(10)),border=NA,main="",fmt.key="%s",key=NULL, axis.row=NULL,cex.lab=0.5,cex.axis=0.5,
     spacing.key=0.4,0.1,0)
mtext("Timestep",1,1.5,cex=0.5)
mtext("Individual",2,1,cex=0.5)

```

However there is definitely a better way of visualising this change over time.

## 6. Alluvial plots for visualising flow between dynamic communities.

MajorTrack comes with a method for plotting the flow of individuals between dynamic communities using [alluvial plots](https://en.wikipedia.org/wiki/Alluvial_diagram). There are a few packages for doing alluvial plots within R that I have experimented with, but so far I have found they don't deal well with things like changing population size. 

The R function for the MT alluvial plots is a wrapper for the python plotting functions. It will run some python code, export an image then bring it back into R. By default the image file will then be removed.

This is the simplest type of alluvial plot:

```{r alluvial1,dpi=600,fig.width=8,fig.height=2,out.width="100%"}



  get_alluvialplot(track,cols)
  

```
Here I provided the MajorTrack object and the vector of colours I have been using throughout. At each timestep, the alluvial plot shows the size of the community in that timestep and the flows between them.

It would be handy if we could distinguish the flows that represent individuals remaining in the same DC between timesteps in a different colour. For example:

```{r alluvial2,dpi=600,fig.width=8,fig.height=2,out.width="100%"}
  #Highlight all moves in blue, remain colour is still in grey
  get_alluvialplot(track,cols,fluxmovecol = "skyblue",fluxremaincol = "grey")
  

```

We can also set the flux colour depending on their source community

```{r alluvial3,dpi=600,fig.width=8,fig.height=2,out.width="100%"}
  
  get_alluvialplot(track,cols,fluxsinglecol = F, fluxsinglecolremain = F)
  

```

or the target community.

```{r alluvial4,dpi=600,fig.width=8,fig.height=2,out.width="100%"}
  
  get_alluvialplot(track,cols,fluxsinglecol = F,fluxbysource = F, fluxsinglecolremain = F)
  

```

As with above, we can choose to separate the flows representing individuals remaining in the same DC. So in this plot, the flows where individuals shift  between different communities, either due to moving or due to splitting and merging, are highlighted in the colour of the source community. 

```{r alluvial5,dpi=600,fig.width=8,fig.height=2,out.width="100%"}
  
  get_alluvialplot(track,cols,fluxsinglecol = F,fluxbysource = T, fluxsinglecolremain = T)
  

```

Other arguments are primarily for controlling the plot. The labeling is passed to the python figure, as are the size and initial margins of the figure. 

The rmargin argument controls where the alluvial plot (blocks and flows) is placed in the overall plotting area. This consists of a vector of numbers between 0 and 1 in the format <b>left,bottom,right,top</b>. By default the alluvial plot takes up the entirety of the plotting area, except for the bottom where a gap is left for the labels (0.2).

Control of the initial size of the exported file is controlled using the figwidth and figheight button. Note that if your R plotting area is different, this can result in squashed looking figures.

You can also control the width of the DCs at each timestep with the cwidth argument, where 1 results in no gap between timesteps and 0 makes the clusters disappear.


```{r alluvial6,dpi=600,fig.width=7,fig.height=2,out.width="100%"}
  get_alluvialplot(track,cols,fluxsinglecol = F,fluxbysource = T, fluxsinglecolremain = T,
                   rlabels=c("a","b","c","d","e","f"),
                   rmargins = c(0.2,0.2,0.8,0.8),
                   figwidth=7,figheight=2,
                   cwidth=0.1,
                   labelsize=5
                   )
  
```

The resulting plotting device will have an x-axis where each tick is a timestep. So for example, we can plot more things on our alluvial plot:

```{r alluvial7,dpi=600,fig.width=7,fig.height=2,out.width="100%"}
  get_alluvialplot(track,cols,fluxsinglecol = F,fluxbysource = T, fluxsinglecolremain = T,
                   rlabels=c("a","b","c","d","e","f"),
                   rmargins = c(0.2,0.2,0.8,0.8),
                   figwidth=7,figheight=2,
                   cwidth=0.2
                   )
  abline(v=c(1,3,6),lwd=2)
  

```


